[{"id":"542f169762b7aca64f020ec0392added","title":"LLM八股文（整理自用_不保证正确）（持续更新）","content":"Attention改进方面Flash_Attention（这一部分主要参考链接：https://readpaper.feishu.cn/docx/AC7JdtLrhoKpgxxSRM8cfUounsh 感谢杨同学）\n在传统的Attention中，softmax(QK^T^&#x2F;dmk^1&#x2F;2^)中的矩阵运算很大，需要在HBM中实例化存储，因此会带来很多的对显存的访存操作，导致耗时较长。\nFlashAttention则是将对QK的softmax计算进行了分片，每次进行部分计算时。计算都能在SRAM中进行交互，从而减少对显存的依赖。\n让我们将softmax(QK^T^&#x2F;dmk^1&#x2F;2^)进行拆分，实际上之前的softmax计算是以行为单位的：\n$$\\begin{equation}m(x):&#x3D;\\max _i x_i, \\quad f(x):&#x3D;\\left[\\begin{array}{lll}e^{x_1-m(x)} &amp; \\ldots &amp; e^{x_B-m(x)}\\end{array}\\right], \\quad \\ell(x):&#x3D;\\sum_i f(x)_i, \\quad \\operatorname{softmax}(x):&#x3D;\\frac{f(x)}{\\ell(x)}\\end{equation}$$\n在Flash_attention中，则对输入进行了分片：\n$$\\begin{equation}\\begin{aligned}&amp; m(x)&#x3D;m\\left(\\left[x^{(1)} x^{(2)}\\right]\\right)&#x3D;\\max \\left(m\\left(x^{(1)}\\right), m\\left(x^{(2)}\\right)\\right), \\quad f(x)&#x3D;\\left[\\begin{array}{ll}e^{m\\left(x^{(1)}\\right)-m(x)} f\\left(x^{(1)}\\right) &amp; e^{m\\left(x^{(2)}\\right)-m(x)} f\\left(x^{(2)}\\right)\\end{array}\\right], \\&amp; \\ell(x)&#x3D;\\ell\\left(\\left[x^{(1)} x^{(2)}\\right]\\right)&#x3D;e^{m\\left(x^{(1)}\\right)-m(x)} \\ell\\left(x^{(1)}\\right)+e^{m\\left(x^{(2)}\\right)-m(x)} \\ell\\left(x^{(2)}\\right), \\quad \\operatorname{softmax}(x)&#x3D;\\frac{f(x)}{\\ell(x)} .\\end{aligned}\\end{equation}$$\n对Flash_Attention的前向和反向传播具体计算数学公式参见：https://readpaper.feishu.cn/docx/AC7JdtLrhoKpgxxSRM8cfUounsh\nPagedAttention（这一部分主要参考链接https://readpaper.feishu.cn/docx/EcZxdsf4uozCoixdU3NcW03snwV： 感谢杨同学）\n当大模型进行推理时，将上一次生成的KV进行缓存产生KVcache能够加速大模型的生成速度\n\n但在现有的KV缓存技术中，缓存仍然存在占用较大，且大小取决于序列长度，不可预测的缺点。这样就造成了内存浪费十分严重（60%到80%）。因此，PagedAttention中将操作系统中的虚拟内存和分页思想引入至注意力算法中。PagedAttention主要有内存布局以固定大小的页为单位，可以进行内存共享的特点\n内存布局对于一次kv计算而言，由于引入了分页机制，其所用的kvcache不再需要在一段连续的内存中。因此内存的利用效率会大大提升（浪费率降低至4%左右），带来batchsize的大大提升，随之而来GPU的利用效率大大提升，显著提升吞吐量\n内存共享在并行采样中，从相同的提示生成多个输出序列。在这种情况下，可以在输出序列之间共享提示的计算和内存。通过其块表，PagedAttention能够自然地实现内存共享。类似于进程共享物理页，PagedAttention中的不同序列可以通过将它们的逻辑块映射到相同的物理块来共享块。为确保安全共享，PagedAttention跟踪物理块的引用计数并实现 Copy-on-Write 机制。\n通过PagedAttention的内存共享机制，极大地降低了复杂采样算法（如ParallelSampling和BeamSearch）的内存开销，使其内存使用量下降了高达55%。这项优化可以直接带来最多2.2倍的吞吐量提升，从而使得LLM服务中使用这些采样方法变得更加实用。\nAttention本身：手撕多头注意力机制：参见https://nn.labml.ai/transformers/mha.html\n这里做个备注：\n137        assert mask.shape[0] &#x3D;&#x3D; 1 or mask.shape[0] &#x3D;&#x3D; query_shape[0]\n138        assert mask.shape[1] &#x3D;&#x3D; key_shape[0]\n139        assert mask.shape[2] &#x3D;&#x3D; 1 or mask.shape[2] &#x3D;&#x3D; query_shape[1]\n这些断言检查传入的 mask 张量是否具有预期的形状：\n行 137: 确保掩码的第一个维度要么是1（表示同一个掩码应用于所有查询），要么与查询序列的长度相同。\n行 138: 确保掩码的第二个维度与键的序列长度相匹配。\n行 139: 确保掩码的第三个维度要么是1（表示同一个掩码应用于所有批次中的查询），要么与批次大小相同。\n","slug":"LLM八股文（整理自用_不保证正确）","date":"2024-04-12T11:40:39.386Z","categories_index":"","tags_index":"","author_index":"Shuo Hong"},{"id":"7be461416c2d0f0593235527ffa02f82","title":"leetcode刷题核心点记录","content":"leetcode 470 用 Rand7() 实现 Rand10()已知 rand_N() 可以等概率的生成[1, N]范围的随机数那么：(rand_X() - 1) × Y + rand_Y() &#x3D;&#x3D;&gt; 可以等概率的生成[1, X * Y]范围的随机数即实现了 rand_XY()\n拒绝采样：如果某个采样结果不在要求的范围内，则丢弃它\n优化：利用不在采样范围内的数据生成采样范围内的数据（目标的倍数）将rand_y()进行灵活转化。\n","slug":"leetcode_核心点记录","date":"2024-03-30T11:38:46.466Z","categories_index":"","tags_index":"","author_index":"Shuo Hong"},{"id":"80a7e21722935a33527e2b073eb00486","title":"2024_3_29记录(秒凉)","content":"第一题 c++,java 基础题脑抽答错了，记得多nk的计算机基础\n第二题 编译型和非编译型SAST的区别答的不是很好，以下是glm4给出的答案\n编译型静态应用程序安全测试（SAST）和非编译型静态应用程序安全测试（SAST）是两种不同的安全测试方法，它们在应用程序的安全评估过程中有不同的应用场景和特点。\n\n编译型SAST：\n编译型SAST工具在编译阶段对源代码进行分析，它需要访问应用程序的源代码。\n这些工具通常可以识别代码中的安全漏洞，如缓冲区溢出、SQL注入等。\n编译型SAST工具可以提供更精确和深入的安全分析，因为它们可以理解代码的结构和逻辑。\n编译型SAST工具通常需要更多的配置和设置，以便正确地集成到开发过程中。\n\n\n非编译型SAST：\n非编译型SAST工具在源代码或字节码上进行操作，不需要编译过程。\n这些工具通常可以检测到源代码中的安全漏洞，如跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等。\n非编译型SAST工具通常更容易集成到开发过程中，因为它们不需要编译步骤。\n非编译型SAST工具可能不如编译型工具那样精确，因为它们不能完全理解代码的结构和逻辑。总的来说，编译型和非编译型SAST工具都有其优缺点，选择哪种工具取决于具体的安全需求和开发环境。在实际应用中，可以将这两种工具结合使用，以获得更全面的安全评估。\n\n\n\n拓展：SAST，DAST和IAST到底是什么？他们之间的优劣势如何？（转载自https://zhuanlan.zhihu.com/p/98007493；作者：DevOps安全社）一、SAST\nSAST（Static Application Security Testing，静态应用程序安全测试）对应用程序源代码执行直接的白盒分析。分析是在代码的静态视图上运行的，这意味着代码在审查时没有运行。如今，SAST已经完全成为主流，并且在整个软件行业中被广泛采用。\nSAST的优点：\n广泛的编程语言支持；\n检出率较高；\n可以定位到代码行。\nSAST的缺点：\n准确性差：优秀SAST产品的误报率也在53%以上*；\n无法看到执行流；\n通常需要一些定制或调参；\n不适用于生产阶段的系统；\n通常运行很慢。\n二、DAST\n与SAST相反，DAST（Dynamic Application Security Testing，动态应用程序安全测试）对应用程序进行黑盒分析，这意味着它们不能访问代码或实现细节。DAST只检查系统对潜在漏洞测试的请求和响应。换言之，DAST是外部的漏洞扫描程序。\nDAST的优点：\n独立于应用程序的技术和平台，无需代码细节；\n执行相对较快；\n误报率较低。\nDAST的缺点：\n检出率低：优秀的DAST产品检出率也只有18%*；\n无法定位到代码行；\n使用门槛高，报告通常需要安全专家解读。\n三、IAST\nIAST（Interactive Application Security Testing，交互式应用程序安全测试）结合了SAST和DAST的优点。IAST可以像SAST一样看到源代码，也可以像DAST一样看到应用程序运行时的执行流。\nIAST的优点：\n检出率较高；\n误报率较低；\n可以在研发测试和生产环境中使用；\n实时产生结果；\n可以持续检测，对DevOps支持度更高；\n即插即用，无需配置或调参；\n可以与CI平台集成，创建相互连接的工作流。\nIAST的缺点：\n需要特定的语言支持\n\n第三题 IDE为何可以在用户编写代码而未运行时报出错误提示；基本上答出来，但太拘泥于细节。\n规则和模式匹配：静态分析工具通常基于一系列预定义的规则和模式来检查代码。这些规则可以是关于代码风格、编程语言的语法、可能的错误或安全漏洞的。工具会扫描代码，寻找与这些规则匹配的模式，并标记出潜在的问题。代码质量检查：静态分析工具可以检测代码中的质量问题，如重复的代码、过于复杂的函数、过长的文件、循环依赖等。这些质量问题可能会影响代码的可维护性和可读性。错误检测：工具可以识别可能导致运行时错误的代码，如空指针引用、数组越界访问、除以零等。通过在开发早期发现这些错误，可以减少调试和修复错误的时间。安全漏洞扫描：静态分析工具可以检查代码中可能的安全漏洞，如SQL注入、跨站脚本（XSS）、缓冲区溢出等。这些漏洞可能会被攻击者利用，导致安全风险。\n第四题 codeql是否可以被修改未无需编译的工具回答组织错乱，以下是我重新组织的回答（不保证正确）\n如果是从原理上来说，codeql本身对特定语言（Python,js等）无需编译，其仅仅倾向于使用编译的方法来获取更多信息，因此codeql可以被修改为无需编译的工具，以JAVA为例，codeql在提取其AST时将其分为stmt.表达式，Map类型等，这些信息都可以使用非编译的工具来提取。但不用编译的方法来提取这些信息，相较于编译方法而言准确度会降低。这就是为什么codeql尽量使用编译的原因。\n第五题 了解哪些类型的漏洞建议参照OWASP Top10来回答，2021版本为：\nA01:2021-权限控制失效 从第五名移上來; 94% 被测试的应用程式都有验证到某种类别权限控制失效的问题。在权限控制失效这个类别中被对应到的 34 个 CWEs 在验测资料中出现的次数都高于其他的弱点类别。\nA02:2021-加密机制失效 提升一名到第二名，在之前为 敏感资料外曝，在此定义下比较类似于一个广泛的问题而非根本原因。在此重新定义并将问题核心定义在加密机制的失败，并因此造成敏感性资料外泄或是系統被破坏。\nA03:2021-注入式攻击 下滑到第三名。94% 被测试的应用程式都有验测到某种类別注入式攻击的问题。在注入式攻击这个类別中被对应到的 33 个 CWEs 在验测资料中出现的次数为弱点问题的第二高。跨站脚本攻击现在在新版本属于这个类別。\nA04:2021-不安全设计 这是 2021 年版本的新类別，并特別聚焦在设计相关的缺陷。如果我们真的希望让整个产业”向左移动”＊注一＊，那我们必须进一步的往威胁建模，安全设计模块的观念，和安全參考架构前进。\n＊注一: Move Left 于英文原文中代表在软件开发及交付过程中，在早期找出及处理相关问题，同 Shift Left Testing。＊\nA05:2021-安全设定缺陷 从上一版本的第六名移动上來。90% 被测试的应用程式都有验测到某种类別的安全设定缺陷。在更多的软件往更高度和有弹性的设定移动，我们并不意外这个类別的问题往上移动。在前版本中的 XML 外部实体注入攻击 （XML External Entities）现在属于这个类別。\nA06:2021-危险或过旧的组件 在之前标题为 使用有已知弱点的组件。在本次版本中于业界问卷中排名第二，但也有足够的统计资料让它可以进入 Top 10。这个类別从 2017 版本的第九名爬升到第六，也是我们持续挣扎做测试和评估风险的类別。这也是唯一一个沒有任何 CVE 能被对应到 CWE 內的类別，所以预设的威胁及影响权重在这类別的分数上被预设为 5.0。\nA07:2021-认证及验证机制失效 在之前标题为 错误的认证机制。在本次版本中由第二名下滑至此，并同时包含了将认证相关缺失的 CWE 包含在內。这个类別仍是 Top 10 不可缺少的一环，但同时也有发现现在标准化的架构有协助降低次风险发生机率。\nA08:2021-软件及资料完整性失效 这是 2021 年版本全新的类別，并在软件更新，敏感及重要资料，和 CI&#x2F;CD 管道中并沒有做完整性的确认为前提做假设并进行评估。在评估中影响权重最高分的 CVE&#x2F;CVSS 资料都与这类別中的 10 个 CWE 对应到。2017 年版本中不安全的反序列化现在被合并至此类別。\nA09:2021-安全记录及监控失效 在之前为不完整的记录及监控并纳入在业界问卷中在本次列名为第三名并从之前的第十名上移。这个类別将扩充去纳入更多相关的缺失，但这也是相当难去验证，并沒有相当多的 CVE&#x2F;CVSS 资料可以佐证。但是在这个类別中的缺失会直接影响到整体安全的可视性，事件告警及取证。\nA10:2021-服务器端请求伪造 这个类別是在业界问卷排名第一名，并在此版本內纳入。由资料显示此问题有较低被验测次数和范围，但有高于平均的威胁及影响权重比率。这个类別的出现也是因为业界专家重复申明这类別的问题相当重要，即使在本次资料中并沒有足够的资料去显示这个问题。\n第六题 污点分析：\n\n\n2024年3月30日更新：\n发现问过的问题很多来源于https://security.tencent.com/index.php/blog/msg/191只能说之后最好多看相关博客，哭笑不得了属于是\n","slug":"2024_3_29记录(秒挂)","date":"2024-03-30T08:46:44.216Z","categories_index":"","tags_index":"","author_index":"Shuo Hong"},{"id":"2c99110fb374d2251c5f6902cacac226","title":".vscode出现fail_to_download_vs_code_server解决办法（转载）","content":"查看失败日志，锁定commit id到外网环境下载：curl -sSL “https://update.code.visualstudio.com/commit:${commit_id}/server-linux-x64/stable” -o vscode-server-linux-x64.tar.gzmkdir -p ~&#x2F;.vscode-server&#x2F;bin&#x2F;${commit_id}tar zxvf &#x2F;tmp&#x2F;vscode-server-linux-x64.tar.gz -C ~&#x2F;.vscode-server&#x2F;bin&#x2F;${commit_id} –strip 1touch ~&#x2F;.vscode-server&#x2F;bin&#x2F;${commit_id}&#x2F;0\n","slug":"vscode出现fail_to_download_vs_code_server解决办法","date":"2024-03-25T13:27:56.055Z","categories_index":"","tags_index":"","author_index":"Shuo Hong"},{"id":"e60c2d9ec695dd65b5dadea96fa55318","title":"如何kill 掉pid一直变化的进程","content":"kill $(ps aux | grep java | tr -s &#39; &#39;| cut -d &#39; &#39; -f 2)其中，java可以替换为其他词\n命令解析：\n\n$(ps aux | grep java)：使用ps命令列出所有正在运行的进程，并使用grep命令筛选出包含”java”字符串的行。\ntr -s &#39; &#39;：将筛选出的行中的空格替换为空字符，以便后续的命令能够正确处理。\ncut -d &#39; &#39; -f 2：使用cut命令从每行中提取第二个字段，即进程ID（PID）\n\ntr命令tr命令是Unix&#x2F;Linux系统中的一个字符替换工具，用于在文本中替换指定的字符或字符集。它的基本语法如下：\n1tr [OPTIONS] SET1 SET2\n\n其中，SET1和SET2是两个字符集，tr命令会将SET1中的每个字符替换为SET2中对应的字符。如果省略SET2，则默认使用空字符替换SET1中的每个字符。\ntr命令的选项包括：\n\n-c：指定替换次数，即最多替换多少个字符。\n-d：指定删除字符集，即删除SET1中的字符。\n-s：指定替换字符集，即SET1中的字符替换为SET2中的字符。\n-t：指定替换字符集，即SET1中的字符替换为SET2中的字符，但只替换第一个匹配项。\n-u：指定替换字符集，即SET1中的字符替换为SET2中的字符，但只替换第一个匹配项，并且删除SET1中的字符。\n\ntr命令常用于文本处理、数据转换等场景，例如将文件中的换行符替换为制表符、将大小写字母互换等。\ncut命令cut命令是Unix&#x2F;Linux系统中的一个文本处理工具，用于从文本中提取指定位置的字段。它的基本语法如下：\n1cut [OPTIONS] [FILE] [START END]\n\n其中，OPTIONS是可选参数，用于指定输出格式、分隔符等；FILE是可选参数，用于指定要处理的文本文件；START和END是可选参数，用于指定要提取的字段范围。\ncut命令的选项包括：\n\n-b：指定分隔符，默认为制表符。\n-c：指定要提取的字段数，例如-c 2表示提取第2个字段。\n-d：指定分隔符，默认为制表符。\n-f：指定输出格式，例如-f 1,3表示输出第1个和第3个字段。\n-s：指定分隔符，默认为制表符。\n-t：指定分隔符，默认为制表符。\n\ncut命令常用于文本处理、数据提取等场景，例如从日志文件中提取IP地址、从CSV文件中提取特定列等。\nKill命令kill $()是一个特殊的命令，用于杀死当前shell进程。具体来说，$()表示当前shell进程的进程ID，因此kill $()会杀死当前shell进程。\n需要注意的是，kill $()命令只能杀死当前shell进程，而不能杀死其他进程。如果需要杀死其他进程，可以使用kill命令，例如kill 1234表示杀死进程ID为1234的进程。\n另外，需要注意的是，kill命令是一种非常危险的操作，如果不小心杀死了一个重要的进程，可能会导致系统崩溃或数据丢失。因此，在使用kill命令时，一定要谨慎操作，确保不会误杀重要进程。\n","slug":"如何kill 掉pid一直变化的进程","date":"2024-02-28T15:16:11.000Z","categories_index":"Daily record","tags_index":"Daily record","author_index":"Shuo Hong"},{"id":"247ac1e7bd99591b6c3fd2ab7eabb900","title":"Hex简易命令（转载）","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"Hexo建议命令","date":"2024-02-27T16:17:50.465Z","categories_index":"","tags_index":"","author_index":"Shuo Hong"},{"id":"801591854ef42c23b79225abd4e53d59","title":"LLM简单评测_2024_2_26","content":"#traing_of_fintuning使用freeze进行微调，目前微调结果如下：微调基于&#x2F;llm&#x2F;LLaMA-Factory&#x2F;zephyr-7b-lora-export，各个情况下的评估代码以及评估结果如下所示：\nzephyr-7b-alpha评估代码：CUDA_VISIBLE_DEVICES&#x3D;0 python src&#x2F;evaluate.py     –model_name_or_path HuggingFaceH4&#x2F;zephyr-7b-alpha  –template vanilla     –quantization_bit 4     –task ceval     –split validation     –lang zh     –n_shot 5     –batch_size 4\n评估结果：Average: 43.24STEM: 44.65Social Sciences: 46.18Humanities: 42.02Other: 40.36\n&#x2F;llm&#x2F;LLaMA-Factory&#x2F;zephyr-7b-lora-export，评估代码：CUDA_VISIBLE_DEVICES&#x3D;0 python src&#x2F;evaluate.py     –model_name_or_path &#x2F;llm&#x2F;LLaMA-Factory&#x2F;zephyr-7b-lora-export  –template vanilla     –quantization_bit 4     –task ceval     –split validation     –lang zh     –n_shot 5     –batch_size 4 \n评估结果：Average: 41.53                                                                                                                  STEM: 40.47Social Sciences: 46.18Humanities: 42.80Other: 38.54\n&#x2F;llm&#x2F;LLaMA-Factory&#x2F;saves&#x2F;Zephyr-7B-Alpha-Chat&#x2F;freeze&#x2F;train_2024-01-01-23-13 （本次）评估代码：CUDA_VISIBLE_DEVICES&#x3D;0,1 accelerate launch  src&#x2F;evaluate.py     –model_name_or_path &#x2F;llm&#x2F;LLaMA-Factory&#x2F;saves&#x2F;Zephyr-7B-Alpha-Chat&#x2F;freeze&#x2F;train_2024-01-01-23-13 –template vanilla    –quantization_bit 4     –task ceval     –split validation     –lang zh     –n_shot 5     –batch_size 4评估结果：Average: 43.16                                                                                                                  STEM: 42.56Social Sciences: 48.00 Humanities: 44.36  Other: 39.58\n下一步：freeze微调相应代码","slug":"LLM简单评测","date":"2024-02-27T15:25:11.000Z","categories_index":"Daily record","tags_index":"Daily record","author_index":"Shuo Hong"},{"id":"aadb4a19073e41a58c91edd26f1f5046","title":"如何使用deepspeed进行多机多卡训练（简易版本）_2024_2_27","content":"deepspeed多机多卡搭建记录（简易）\n0 docker网络搭建https://www.jianshu.com/p/2792ebf9af71\n1 配置免密登录https://blog.csdn.net/qq_40732354/article/details/95061228\n2 deepspeed配置https://www.jianshu.com/p/2792ebf9af71注：hostfile为 ip slot=[gpu数量]即可\nbug 解决方案deepspeed 报错 up NCCL communicator and retreiving ncclUniqueId from [0] via c10d key-value store 解决https://blog.csdn.net/qq874455953/article/details/134408257\n","slug":"how-to-use-deepspeed-on-many-servers-record-2024-2-27 copy","date":"2024-02-27T15:25:11.000Z","categories_index":"Daily record","tags_index":"Daily record","author_index":"Shuo Hong"}]