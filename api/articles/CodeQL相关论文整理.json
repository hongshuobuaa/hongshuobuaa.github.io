{"title":"CodeQL相关论文整理(持续更新中)","uid":"da5f341d43fdcb48713cf189ba6fcbc4","slug":"CodeQL相关论文整理","date":"2024-04-24T13:25:17.132Z","updated":"2024-04-25T01:47:41.509Z","comments":true,"path":"api/articles/CodeQL相关论文整理.json","keywords":null,"cover":"https://tse1-mm.cn.bing.net/th/id/OIP-C.1qC9gL83V6TVXwAXmyQj8QHaHa?rs=1&pid=ImgDetMain","content":"<p>前排提醒，本文中与codeql相关的论文为按照时间线整理，数据来源为：<a href=\"https://codeql.github.com/publications/\">https://codeql.github.com/publications/</a> 论文整理仅为自用，可能有错漏之处，还望批评指正。</p>\n<h1 id=\"2007年：QL-for-Source-Code-Analysis\"><a href=\"#2007年：QL-for-Source-Code-Analysis\" class=\"headerlink\" title=\"2007年：QL for Source Code Analysis.\"></a>2007年：QL for Source Code Analysis.</h1><p><strong>（<a href=\"https://codeql.github.com/publications/ql-for-source-code-analysis.pdf%EF%BC%89\">https://codeql.github.com/publications/ql-for-source-code-analysis.pdf）</a></strong></p>\n<p>这篇论文是官网中所提到的第一篇论文，这里论文作者在一开头就解释了：</p>\n<p>（1）CodeQL（当时还叫.QL）为什么要采用类SQL语句？即单纯为了降低开发者的学习障碍，且这种相似性只在语法上。</p>\n<p>（2）CodeQL会被编译成什么语句? CodeQL最后会被编译为DataLog语句，因为datalog的查询是可以递归的，这对查询继承层次结构或调用图非常重要。</p>\n<p>（3）CodeQL使用的是Eindhoven Quantifier Notation（埃因霍温量化符表示法），一种优雅的计算某些度量属性的方法</p>\n<p>（4）面向对象查询语言的语义模型应该怎么设计：.QL 采取了一个看似简单且一致的观点，即类是谓词，继承是蕴含。这种观点具有简单性的优势，但严格应用这些原则会导致一些初看起来令人惊讶的后果，特别是需要非确定性表达式。然而，允许非确定性表达式确实使得查询更加简洁，从而改善了语言设计。</p>\n<p>除此之外，论文还介绍了CodeQL的早期版本：SemmleCode。其为使用abc代码库为例子进行测试</p>\n<p>整个查询过程可以分为以下几个阶段：</p>\n<p>（1）选择语句</p>\n<p>这里要注意几点。第一，这个阶段本身可以进行路径无关的Bug的检测。第二，与sql的select语句相比，变量在使用前被声明。</p>\n<p>（2）谓词（Predicates）</p>\n<p>可以类比为codeql对对象操作的”函数“。例如（以下论文原文）：</p>\n<p>查询可以通过将它们包装在谓词中来命名和参数化。为了说明这一点，我们在 abcplus 中构建两个给定类型之间的所有类型的图。首先，我们定义一个测试，以检查从下层（down）通过中间（between）到上层（up）的路径在层次结构中是否存在：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">predicate between(RefType down, RefType between, RefType up) &#123;</span><br><span class=\"line\">    down.hasSupertype∗(between) and</span><br><span class=\"line\">    between.hasSupertype∗(up)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，t1.hasSupertype(t2) 是一个测试，用于确定 t1 是否有直接的超级类型 t2。表达式 t1.hasSupertype∗(t2) 中的星号表示间接性：存在从 t1 到 t2 的超级类型链（可能长度为零）。</p>\n<p>现在，这个谓词可以用于另一个查询，以找到从 abc.aspectj.ast.AdviceDecl c（表示建议声明）到 polyglot.ast.Node 的所有路径：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from RefType c1, RefType c2,</span><br><span class=\"line\">RefType node, RefType adviceDecl</span><br><span class=\"line\">where</span><br><span class=\"line\">    node.hasQualifiedName(&quot; polyglot . ast&quot;,&quot;Node&quot;) and</span><br><span class=\"line\">    adviceDecl.hasQualifiedName(&quot;abc. aspectj . ast&quot;,&quot;AdviceDecl c&quot;) and</span><br><span class=\"line\">    between(adviceDecl,c1,node) and</span><br><span class=\"line\">    between(adviceDecl,c2,node) and</span><br><span class=\"line\">    c2.hasSupertype(c1)</span><br><span class=\"line\">select c1,c2</span><br></pre></td></tr></table></figure>\n\n<p>（3）聚合</p>\n<p>这里直接使用了埃因霍温量化符表示法，让推理证明变得简洁。<br>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from Package p</span><br><span class=\"line\">where p.hasName(&quot;abc.aspectj. ast&quot;)</span><br><span class=\"line\">select sum(CompilationUnit cu |</span><br><span class=\"line\">    cu.getPackage()=p |</span><br><span class=\"line\">    cu.getNumberOfLines())</span><br></pre></td></tr></table></figure>\n\n\n\n<p>（4）类</p>\n<p>Codeql支持面向对象，可以编写自己的类</p>\n<p>在这篇文章的版本中 codeql还没有引入控制流</p>\n<h1 id=\"2007-QL-Object-Oriented-Queries-Made-Easy-（要钱，没看）\"><a href=\"#2007-QL-Object-Oriented-Queries-Made-Easy-（要钱，没看）\" class=\"headerlink\" title=\"2007 QL: Object-Oriented Queries Made Easy.（要钱，没看）\"></a>2007 QL: Object-Oriented Queries Made Easy.（要钱，没看）</h1><p><strong>(<a href=\"https://pdfs.semanticscholar.org/d7be/52e78154dbde1884f07510fa7901b9915277.pdf\">https://pdfs.semanticscholar.org/d7be/52e78154dbde1884f07510fa7901b9915277.pdf</a>)</strong></p>\n<hr>\n<hr>\n<h1 id=\"2008-Adding-Magic-to-an-Optimising-Datalog-Compiler\"><a href=\"#2008-Adding-Magic-to-an-Optimising-Datalog-Compiler\" class=\"headerlink\" title=\"2008 Adding Magic to an Optimising Datalog Compiler\"></a>2008 Adding Magic to an Optimising Datalog Compiler</h1><p><strong>(<a href=\"https://dl.acm.org/authorize?N84086\">https://dl.acm.org/authorize?N84086</a>)</strong></p>\n<p>这里，codeql团队尝试了使用.ql转化为datalog，之后再转化为sql.</p>\n<h1 id=\"2008-Type-Inference-for-Datalog-and-Its-Application-to-Query-Optimisation\"><a href=\"#2008-Type-Inference-for-Datalog-and-Its-Application-to-Query-Optimisation\" class=\"headerlink\" title=\"2008 Type Inference for Datalog and Its Application to Query Optimisation.\"></a>2008 Type Inference for Datalog and Its Application to Query Optimisation.</h1><p><strong>(<a href=\"https://dl.acm.org/authorize?N84087\">https://dl.acm.org/authorize?N84087</a>)</strong></p>\n<p>这篇文章中，codeql团队尝试了使用非笛卡尔类型的方法进行类型推断的效果。</p>\n<h1 id=\"2010-Type-Inference-for-Datalog-with-Complex-Type-Hierarchies\"><a href=\"#2010-Type-Inference-for-Datalog-with-Complex-Type-Hierarchies\" class=\"headerlink\" title=\"2010 Type Inference for Datalog with Complex Type Hierarchies.\"></a>2010 Type Inference for Datalog with Complex Type Hierarchies.</h1><p><strong>(<a href=\"https://dl.acm.org/doi/10.1145/1707801.1706317?cid=81381592942\">https://dl.acm.org/doi/10.1145/1707801.1706317?cid=81381592942</a>)</strong></p>\n<p>Datalog 的类型推断可以理解为将程序映射到一个子语言的问题，该子语言的包含性是可判定的。具体来说，给定一个 Datalog 程序、一个描述扩展关系类型的模式，以及用户提供的关于基本类型的基本事实（声明条件，如不相交性、蕴含或等价性），我们旨在推断出程序语义的近似表示，这个表示应该可以用 Datalog 的一个合适的子语言来表达。</p>\n<p>我们主张 Datalog 加上单值扩展（monadic extensionals）是那个类型子语言的一个合适选择，并介绍了推断算法。该推断算法被证明是可靠的，我们还展示它为一大类 Datalog 程序推断出了尽可能紧致的近似表示。此外，我们为我们的类型语言的大一部分呈现了一个实用的包含性检查。这个包含性检查的核心是一种对 Quine 计算原蕴涵（prime implicants）程序的新颖推广。该类型系统已在最先进的工业数据库系统中实现，我们报告了关于这一实现的实验。</p>\n<h1 id=\"2015-Tracking-Static-Analysis-Violations-Over-Time-to-Capture-Developer-Characteristics\"><a href=\"#2015-Tracking-Static-Analysis-Violations-Over-Time-to-Capture-Developer-Characteristics\" class=\"headerlink\" title=\"2015 Tracking Static Analysis Violations Over Time to Capture Developer Characteristics.\"></a>2015 Tracking Static Analysis Violations Over Time to Capture Developer Characteristics.</h1><p><strong>(<a href=\"https://codeql.github.com/publications/tracking-analysis-violations.pdf\">https://codeql.github.com/publications/tracking-analysis-violations.pdf</a>)</strong></p>\n<p>我们提出了一种方法，用于跟踪程序的修订历史中静态分析违规（通常表明缺陷）的情况，并精确地将这些违规的引入和消除归因于个别开发者。</p>\n<h1 id=\"2016-QL-Object-oriented-Queries-on-Relational-Dat（CodeQL中最具代表性的部分）\"><a href=\"#2016-QL-Object-oriented-Queries-on-Relational-Dat（CodeQL中最具代表性的部分）\" class=\"headerlink\" title=\"2016 QL: Object-oriented Queries on Relational Dat（CodeQL中最具代表性的部分）\"></a>2016 QL: Object-oriented Queries on Relational Dat（CodeQL中最具代表性的部分）</h1><p><strong>(<a href=\"http://drops.dagstuhl.de/opus/volltexte/2016/6096/pdf/LIPIcs-ECOOP-2016-2.pdf\">http://drops.dagstuhl.de/opus/volltexte/2016/6096/pdf/LIPIcs-ECOOP-2016-2.pdf</a>)</strong></p>\n<p><strong>开始出现CFG</strong></p>\n<p>本文描述了QL，一种查询复杂、可能递归的数据结构的查询语言。QL编译成Datalog并在标准关系数据库上运行，但它提供了类似的对象导向特性，如类和方法，这些特性在逻辑术语中被重新解释：类是描述值集的逻辑属性，子类化是蕴含，虚拟调用是通过考虑接收者包含的最具体类来动态分派。此外，QL中的类型是规定性的，并积极影响程序评估，而不仅仅是描述它。结合这些特性，可以基于可重用库开发简洁的查询，这些库以纯声明式风格编写，但即使在大数据集上也能高效执行。特别是，我们使用QL为各种编程语言实现了静态分析，这些分析可以扩展到数百万行代码。</p>\n<h1 id=\"2017-Algebraic-Data-Types-for-Object-oriented-Datalog\"><a href=\"#2017-Algebraic-Data-Types-for-Object-oriented-Datalog\" class=\"headerlink\" title=\"2017 Algebraic Data Types for Object-oriented Datalog.\"></a>2017 Algebraic Data Types for Object-oriented Datalog.</h1><p><strong>(<a href=\"https://codeql.github.com/publications/algebraic-data-types.pdf\">https://codeql.github.com/publications/algebraic-data-types.pdf</a>)</strong></p>\n<p>Datalog 是一种流行的语言，用于实现程序分析：不仅因为它是一种优雅的正式化，可以简洁地指定最小固定点算法，这是程序分析的基本组成部分，而且这些声明式规范也可以高效执行。然而，纯 Datalog 只能处理原子值，并没有为任何类型的结构化数据提供第一类支持。这使得需要甚至非常简单的数据结构（如对偶）的算法表达起来非常繁琐，而对于需要树或列表的算法来说则完全不可能。因此，非平凡分析往往依赖于允许在空中创建新值来表示复合数据的额外逻辑特性。我们提出了一种更高级的解决方案：我们扩展了 QL，一种面向对象的 Datalog 方言，并引入了一种代数数据类型的概念，它提供了通常的组合、不相交并集和递归。此外，代数数据类型的分支可以是完整的 QL 谓词，它们不仅可以与其他数据类型递归，还可以与任意的其他谓词递归，从而能够对数据类型的结构进行非常细粒度的控制。新的类型与 QL 现有的类和虚拟分派概念无缝集成，后者扮演着模式匹配构建的角色。我们通过扩展 QL 评估器，添加了一个在运行时创建新值的低级操作符，并将代数数据类型翻译为应用此操作符的方法。为了展示我们方法的实际有用性，我们讨论了三个案例研究，这些案例研究涉及 QL 之前难以或无法解决的一般程序分析问题。</p>\n<h1 id=\"2018-Measuring-software-development-productivity-a-machine-learning-approach\"><a href=\"#2018-Measuring-software-development-productivity-a-machine-learning-approach\" class=\"headerlink\" title=\"2018 Measuring software development productivity: a machine learning approach.\"></a>2018 Measuring software development productivity: a machine learning approach.</h1><p><strong>(<a href=\"https://codeql.github.com/publications/measuring-software-development.pdf\">https://codeql.github.com/publications/measuring-software-development.pdf</a>)</strong></p>\n<p>开始尝试机器学习的在静态分析的应用</p>\n<h1 id=\"2019-The-standard-coder-a-machine-learning-approach-to-measuring-the-effort-required-to-produce-source-code-change\"><a href=\"#2019-The-standard-coder-a-machine-learning-approach-to-measuring-the-effort-required-to-produce-source-code-change\" class=\"headerlink\" title=\"2019 The standard coder: a machine learning approach to measuring the effort required to produce source code change.\"></a>2019 The standard coder: a machine learning approach to measuring the effort required to produce source code change.</h1><p><strong>(<a href=\"https://arxiv.org/abs/1903.02436\">https://arxiv.org/abs/1903.02436</a>)</strong></p>\n<p>进一步尝试机器学习的在静态分析的应用</p>\n<h1 id=\"2019-Unsupervised-Recalibration\"><a href=\"#2019-Unsupervised-Recalibration\" class=\"headerlink\" title=\"2019 Unsupervised Recalibration.\"></a>2019 Unsupervised Recalibration.</h1><p><strong>(<a href=\"https://arxiv.org/pdf/1908.09157.pdf\">https://arxiv.org/pdf/1908.09157.pdf</a>)</strong></p>\n<p>无监督重新校准（URC）是一种通用的方法，可以在现场部署的已经训练好的概率分类或回归模型遇到新数据时提高其准确性。URC 无需与新现场数据相关联的任何真实值。URC 仅观察模型的预测，并注意到预测的预期分布与实际分布之间的差异，从而识别出训练数据集可能不具代表性。它通过反向工作来确定偏差的大小，然后将其消除。<br>当应用于现场观察到的不同子群体时，URC 特别有用，这些子群体在训练机器学习模型时并未被视为特征。这使得可以利用子群体的信息，而无需重新训练模型，甚至对于某些或所有子群体无需真实值。<br>此外，如果这些子群体是研究对象，URC 有助于确定它们的正确真实值分布，其中简单的聚合方法，如平均模型的预测，系统性地低估了它们之间的差异。</p>\n","feature":true,"text":"前排提醒，本文中与codeql相关的论文为按照时间线整理，数据来源为：https://codeql.github.com/publications/ 论文整理仅...","permalink":"/post/CodeQL相关论文整理","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2007%E5%B9%B4%EF%BC%9AQL-for-Source-Code-Analysis\"><span class=\"toc-text\">2007年：QL for Source Code Analysis.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2007-QL-Object-Oriented-Queries-Made-Easy-%EF%BC%88%E8%A6%81%E9%92%B1%EF%BC%8C%E6%B2%A1%E7%9C%8B%EF%BC%89\"><span class=\"toc-text\">2007 QL: Object-Oriented Queries Made Easy.（要钱，没看）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2008-Adding-Magic-to-an-Optimising-Datalog-Compiler\"><span class=\"toc-text\">2008 Adding Magic to an Optimising Datalog Compiler</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2008-Type-Inference-for-Datalog-and-Its-Application-to-Query-Optimisation\"><span class=\"toc-text\">2008 Type Inference for Datalog and Its Application to Query Optimisation.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2010-Type-Inference-for-Datalog-with-Complex-Type-Hierarchies\"><span class=\"toc-text\">2010 Type Inference for Datalog with Complex Type Hierarchies.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2015-Tracking-Static-Analysis-Violations-Over-Time-to-Capture-Developer-Characteristics\"><span class=\"toc-text\">2015 Tracking Static Analysis Violations Over Time to Capture Developer Characteristics.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2016-QL-Object-oriented-Queries-on-Relational-Dat%EF%BC%88CodeQL%E4%B8%AD%E6%9C%80%E5%85%B7%E4%BB%A3%E8%A1%A8%E6%80%A7%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%89\"><span class=\"toc-text\">2016 QL: Object-oriented Queries on Relational Dat（CodeQL中最具代表性的部分）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2017-Algebraic-Data-Types-for-Object-oriented-Datalog\"><span class=\"toc-text\">2017 Algebraic Data Types for Object-oriented Datalog.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2018-Measuring-software-development-productivity-a-machine-learning-approach\"><span class=\"toc-text\">2018 Measuring software development productivity: a machine learning approach.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2019-The-standard-coder-a-machine-learning-approach-to-measuring-the-effort-required-to-produce-source-code-change\"><span class=\"toc-text\">2019 The standard coder: a machine learning approach to measuring the effort required to produce source code change.</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2019-Unsupervised-Recalibration\"><span class=\"toc-text\">2019 Unsupervised Recalibration.</span></a></li></ol>","author":{"name":"Shuo Hong","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/65355046?v=4","link":"/","description":"你好，我是来自北京航空航天大学的洪硕","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"python和协程进行IO多路复用的例子","uid":"255c3f38c555c61c61771065e0b22e41","slug":"python_io多路复用样例","date":"2024-04-27T14:05:40.900Z","updated":"2024-04-27T14:06:31.480Z","comments":true,"path":"api/articles/python_io多路复用样例.json","keywords":null,"cover":null,"text":"使用Python进行IO多路复用的一个常见方法是使用asyncio库，这是Python中用于编写单线程并发代码的库，底层使用selectors模块实现IO多路复...","permalink":"/post/python_io多路复用样例","photos":[],"count_time":{"symbolsCount":916,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Shuo Hong","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/65355046?v=4","link":"/","description":"你好，我是来自北京航空航天大学的洪硕","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"LLM_LangChain八股文（整理自用_不保证正确）（持续更新）","uid":"33d3a0a2cbefdcf717ea2b53096214d6","slug":"LLM_langchain八股文","date":"2024-04-14T14:21:58.196Z","updated":"2024-04-15T01:52:41.669Z","comments":true,"path":"api/articles/LLM_langchain八股文.json","keywords":null,"cover":"https://raw.githubusercontent.com/hexojs/logo/master/hexo-logo-avatar.png","text":"LangChain本身什么是 LangChain?LangChain 是一个开发由语言模型驱动的应用程序的框架。我们相信最强大和不同的应用程序不仅会通过 API...","permalink":"/post/LLM_langchain八股文","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"Shuo Hong","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/65355046?v=4","link":"/","description":"你好，我是来自北京航空航天大学的洪硕","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}