{"title":"python和协程进行IO多路复用的例子","uid":"255c3f38c555c61c61771065e0b22e41","slug":"python_io多路复用样例","date":"2024-04-27T14:05:40.900Z","updated":"2024-05-06T08:29:23.296Z","comments":true,"path":"api/articles/python_io多路复用样例.json","keywords":null,"cover":null,"content":"<p>使用Python进行IO多路复用的一个常见方法是使用<code>asyncio</code>库，这是Python中用于编写单线程并发代码的库，底层使用<code>selectors</code>模块实现IO多路复用。以下是一个简单的例子，展示了如何使用<code>asyncio</code>和协程来同时处理多个IO操作。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">def</span> <span class=\"title function_\">say_after</span>(<span class=\"params\">delay, what</span>):</span><br><span class=\"line\">    <span class=\"keyword\">await</span> asyncio.sleep(delay)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(what)</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;started at <span class=\"subst\">&#123;time.strftime(<span class=\"string\">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 创建两个协程</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> asyncio.gather(</span><br><span class=\"line\">        say_after(<span class=\"number\">1</span>, <span class=\"string\">&#x27;hello&#x27;</span>),</span><br><span class=\"line\">        say_after(<span class=\"number\">2</span>, <span class=\"string\">&#x27;world&#x27;</span>)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;finished at <span class=\"subst\">&#123;time.strftime(<span class=\"string\">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class=\"line\">asyncio.run(main())</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，<code>main</code>函数是使用<code>async</code>定义的异步函数，它调用<code>asyncio.gather</code>来同时运行两个<code>say_after</code>协程。这两个协程分别等待1秒和2秒，然后打印一条消息。<code>asyncio.run(main())</code>启动事件循环，并运行<code>main</code>协程直到完成。<br><code>asyncio.sleep</code>函数是一个协程，它会挂起当前任务，但不会阻塞事件循环，这样事件循环就可以在等待期间执行其他任务。<br>请注意，为了确保代码能在所有Python版本中运行，上面的例子假设你已经导入了<code>time</code>模块，并且在你的环境中<code>asyncio.run</code>是可用的（它在Python 3.7及以后版本中可用）。<br>这个例子演示了<code>asyncio</code>如何实现并发行为，而无需使用多线程或多进程。这种方式在IO密集型应用中特别有用，因为它允许你以单线程的方式处理多个IO操作，从而减少了上下文切换的开销。</p>\n<h1 id=\"如何在python中使用协程在短时间内将一百万个文件中的有效信息提取出来？\"><a href=\"#如何在python中使用协程在短时间内将一百万个文件中的有效信息提取出来？\" class=\"headerlink\" title=\"如何在python中使用协程在短时间内将一百万个文件中的有效信息提取出来？\"></a>如何在python中使用协程在短时间内将一百万个文件中的有效信息提取出来？</h1><p>在Python中，你可以利用异步编程和协程来高效处理大量文件的读取和处理任务，尤其是当处理过程涉及IO操作（如文件读取）时，可以显著提高效率。下面是一个简化的示例，演示如何使用asyncio和aiofiles库来并行读取文件中的有效信息。请注意，实际应用中有效信息的定义需要根据你的具体需求来提取。</p>\n<p>首先，确保你安装了aiofiles库，这是异步处理文件的库，可以通过pip安装：</p>\n<p>Bash<br>pip install aiofiles</p>\n<p>然后，以下是一个基本的异步协程示例，用于读取文件（这里简化为读取文件并打印内容，实际情况下你需要替换为提取有效信息的逻辑）：</p>\n<p>Python<br>import asyncio<br>import aiofiles<br>import os</p>\n<p>async def read_and_process_file(file_path):<br>    “””<br>    异步读取文件并模拟处理<br>    “””<br>    async with aiofiles.open(file_path, mode&#x3D;’r’) as file:<br>        content &#x3D; await file.read()<br>        # 这里假设有效信息的处理，你可以替换为实际的处理逻辑<br>        print(f”处理文件: {file_path} - 内容: {content[:100]}…（处理逻辑应在此处实现）”)</p>\n<p>async def main(directory):<br>    “””<br>    主函数，组织协程并执行<br>    “””<br>    files &#x3D; [os.path.join(directory, f) for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">tasks = [read_and_process_file(file) for file in files]</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">await asyncio.gather(*tasks)</span></span></code></pre></div><p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>    directory &#x3D; ‘你的文件目录’  # 指定包含一百万个文件的目录<br>    asyncio.run(main(directory))</p>\n","feature":true,"text":"使用Python进行IO多路复用的一个常见方法是使用asyncio库，这是Python中用于编写单线程并发代码的库，底层使用selectors模块实现IO多路复...","permalink":"/post/python_io多路复用样例","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%9C%A8python%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%9C%A8%E7%9F%AD%E6%97%B6%E9%97%B4%E5%86%85%E5%B0%86%E4%B8%80%E7%99%BE%E4%B8%87%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%9C%89%E6%95%88%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E5%87%BA%E6%9D%A5%EF%BC%9F\"><span class=\"toc-text\">如何在python中使用协程在短时间内将一百万个文件中的有效信息提取出来？</span></a></li></ol>","author":{"name":"Shuo Hong","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/65355046?v=4","link":"/","description":"你好，我是来自北京航空航天大学的洪硕","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"AIGC信息随笔_2024_4_28","uid":"80b3295c405f37b732a74987a11f156e","slug":"AIGC信息随笔_2024_4_28","date":"2024-04-28T07:16:43.950Z","updated":"2024-04-28T07:25:29.045Z","comments":true,"path":"api/articles/AIGC信息随笔_2024_4_28.json","keywords":null,"cover":null,"text":"Huggingface 发布 fineweb 预训练数据集FineWeb是一个由Hugging Face提供的大规模英语网页数据集，包含超过15万亿个经过清洗和...","permalink":"/post/AIGC信息随笔_2024_4_28","photos":[],"count_time":{"symbolsCount":448,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Shuo Hong","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/65355046?v=4","link":"/","description":"你好，我是来自北京航空航天大学的洪硕","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"CodeQL相关论文整理(持续更新中)","uid":"da5f341d43fdcb48713cf189ba6fcbc4","slug":"CodeQL相关论文整理","date":"2024-04-24T13:25:17.132Z","updated":"2024-04-25T01:47:41.509Z","comments":true,"path":"api/articles/CodeQL相关论文整理.json","keywords":null,"cover":"https://tse1-mm.cn.bing.net/th/id/OIP-C.1qC9gL83V6TVXwAXmyQj8QHaHa?rs=1&pid=ImgDetMain","text":"前排提醒，本文中与codeql相关的论文为按照时间线整理，数据来源为：https://codeql.github.com/publications/ 论文整理仅...","permalink":"/post/CodeQL相关论文整理","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"Shuo Hong","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/65355046?v=4","link":"/","description":"你好，我是来自北京航空航天大学的洪硕","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}